# Convention Based Registration

Many use and are well aware of the benefits of IoC containers.  They help us eliminate tightly coupling between our components and save us the painful task of newing everything up manually.  Containers though come with a set of best practices that few fully appreciate or follow.  Here are some that I would:

1. **Clean Constructor** - For constructor injected dependencies (which should be almost all dependencies within a system) value types such as strings should never be passed in a constructor.  This is a code smell.  A common mistake I’ve seen is passing a connection string as a constructor parameter.  Why this is wrong in the context of containers is it forces the registration code to obtain the needed values / connection string.  Many time this results in registration code with a delegate / lambda that obtains the needed value then new’s up and return the created component.  Wait, did you catch that.  Our registration code is now explicitly using the new keyword…we just violated what we set out to do with containers in the first place….eliminate new.

2. **Single Constructor** - Often I’ve seen components with multiple constructors, one that maybe supports inverting all the dependencies, the other a “default” type constructor that makes some common assumptions.  The reasoning usually stems from several different use cases trying to be answered for different consumers (i.e. I needed a way to test this class but my runtime consumers don’t need to worry about it).  First, this leaves your consumers guessing on your intent and forces them to make a decision.  Second, it opens the door for not inverting all your dependencies.  In the case of a unit test, absolute control of all the dependencies is required.  But the same is true for any system, what if the code in a library is awesome except for one small part, one class is wrong…maybe it is logging to a flat file and you want to just do a console write line.  If the code is peppered with multiple constructors it will be very difficult to figure out exactly all the spots in registration code that may need to change to swap out the one component.  With a single constructor there is no guess work.  Third and finally, the ease of use arguments for default constructors is why we are using containers to start with.  They solve that problem nicely for us.
3. **Simple Constructor** - A constructor’s job is simply to collect the necessary dependencies for the component.  It is not the place to invoke those dependencies, perform other logic, etc.  First, there are technical reasons for this.  When a system starts it needs to instantiate a lot of components simply to get to the point of running.  If one of the components fails during construction, the system will crash and do so at a very vulnerable time in the processes lifecycle.  I’ve debugged several systems over the years that had issues crashing upon start.  These can be very tricky to troubleshoot and often require advanced debugging techniques such as windbg, crashdumps, or elevated access to get at the root cause.  Built in logging many times isn’t available because the necessary components were not instantiated yet or hooked into startup sequences in time.  To be clear, it is perfectly acceptable and desirable for a process to exit if a critical failure is detected, just defer this to steps after construction.  Second, with a system that has a lot of components, a common thing is to miss a required dependency (missed registration, implementation of an interface, etc.).  A very common and helpful unit test is to validate the container.  Ensuring all registered components can be constructed.  Simple injector supports this but writing this for other IoC’s or in a generic container context isn’t that hard either.  If the constructors invoke the dependencies such as getting configuration values from IConfiguration, well…now the unit test needs to make sure those things are in place and work.  Worse yet, if we have constructors making database calls or other things, well…that’s not unit testable anymore.  For those kinds of scenarios consider lazy load on first call or other strategies.  Again, move that code out of the constructor.  In the case of IConfiguration, I’ve sometimes compromised to allow this one dependency to be invoked in constructors although even then I will cringe.  Performance costs with getting configuration values from IConfiguration are miniscule.  If there still is a concern, wrap it in a factory, strategy, or other pattern to get the configuration value and perform whatever caching you want. 
4. **Eliminate Decorator Pattern** - I want to be clear that the decorator pattern is a valid pattern.  The problem with it though is that it doesn’t play well with others.  First, containers understandably have issues handling the decorator pattern.  It is basically a form of infinite recursion for construction (constructor takes the same abstraction implemented by the class).  Some containers handle this well like simple injector but most do not.  Second, decorators behave differently based on sequencing.  Consider the scenario of a service call (InvokeService) that is wrapped by two decorators: one that caches the service call (CacheService) and another that logs the service call (LogService).  Now think about ordering of decoration and you quickly realize that CacheService(LogService(InvokeService)) != LogService(CacheService(InvokeService)).  That means the order in which we register decorators is very important.  This is a form of sequential coupling and is generally something to avoid whenever possible.  Conceptually I can agree with the decorator pattern usefulness but like I said, it doesn’t play well with others.
5. **Container Independence** - Container code should only exist in the registration portion of your system and nowhere else.  The reasoning is simple, what if someone wants to consume your code but is using a different container library, what if they just want to use a few classes.  If the container of choice is baked into the code base that is a hard dependency that others must deal with.
6. **Simple Registration** - Sometimes when multiple implementations for an abstraction are needed, we resolve the decision of which one to pick using decision logic in the registration code itself.  This code usually depends on other factors such as dev vs prod, configuration, etc. for the decision tree.  This complexity should not be managed through registration code (quickly turns into SRP violation), it should be managed using a factory pattern.  Thus the factory takes on the responsibility to picking the correct component for the given situation.  Oh and then we can easily unit test that decision logic…another benefit.