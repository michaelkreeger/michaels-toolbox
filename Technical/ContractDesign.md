# Contract Design – Service Contracts

When we have components that live in different processes many times hosted on different servers, one of the first questions we ask is “how” will these components communicate.  How will component A on server A communicate (aka be coupled) with component B on server B.  In almost all cases, we default to http/https over TCP.  There are other options (UDP, raw TCP, named pipes, etc.) but http endpoints is pretty much our first goto.  Why?  Why do we favor this over other solutions?  The simple answer is that it is so universal.  Any language worth its salt will support some way to communicate with http endpoints hosted over TCP.  This is so standard in our thought processes that we often skip this question and jump right into discussions about further details with the protocol itself (REST, RPC, json, xml, etc.).  Now its worth noting that sometimes for performance we are forced to abandon this robust solution and use some lower level protocols with highly compacted and optimized communication mechanisms.  We generally do though with sadness in our heart as we know the vast ecosystem we are giving up.  Finally, there is another way components are coupled together across processes and servers and that is through what I would classify as hand offs.  Generally, a file of some defined format is dropped in a network share and then another process watches for that file and starts to process it.  I see this as more of a storage contract so will defer that for a future post on storage contracts.  For now assume we require some form of synchronous communication between components across processes and servers.
This focus on “how” we will couple components together cross process / server is the first part of contract design for service contracts.  It also is a good opportunity to introduce one of the earliest works on the subject, Postel’s Law otherwise referred to as the Robustness Principle.  In 1980 Jon Postel in his work on the TCP protocol gave the following guiding philosophy on the subject:
“Be conservative in what you do, be liberal in what you accept from others”
This principle has subsequently been referenced by others as a basis for designs and architectures that allow a broad set of technologies, protocols, message structures, etc. to be supported.  This is loose coupling.  A tenant of good design and architecture.  Just like with cases where we favor coupling to abstract classes or interfaces over concretes, with service contracts we favor coupling to the mechanism that provides us with the most flexibility for change in the future.  If we decide that component A in server A needs to be switched out, as long as we can communicate with the service using HTTP we are good.  So, looking at this more broadly, when we discuss the “how” of contract design at least with service contracts we favor those approaches which give us the greatest flexibility, we favor loose coupling.
Now for the more interesting topic in my opinion, the “what” with service contract design.  What we are coupling is a question that generally boils down to an agreed upon request and response structure or contract.  If component A needs a customer name for a given customer identifier, then it seems logical that a contract would be established between component A and B where by component A sends some sort of customer ID either as a query string parameter or other and component B on the other end will send back the customers name.  Well, this is pretty strait forward and also outlines how this discussion should go.  A need or business problem is identified and then, and only then, is the contract designed.  While this seems simple, it is amazing how often we design service contracts before the customers has had a chance to speak.  More on this later.  It gets worse.  Let’s say component C comes along and has a different business problem, it needs customer name and address.  Well, most simply modify the prior contract to now include address.  That induces risks that we may break the existing work done to connect components A and B.  Say for instance that we have thousands or millions of transactions between component A and B and component C which needs the customers address is only expected to have a few transactions per month…can we justify the impact?  Think of the added overhead with adding address will now be flying over the wire even it’s not even used.  What if a bug is introduced and we forget to handle a null value on say AddressLine2 for customers without a second address line or a max field length limit causes an issue?  What about the testing footprint that has now been dramatically increased?  Think about this from an agile perspective and trying to get business value delivered as fast as possible…think of all the extra testing or risk mitigation that may be needed.  Let’s look at this from a coupling standpoint.  Robert Martin in his principles of SOLID mentions ISP – Interface Segregation Principle.  In this his guiding thought is that components should not depend on things they do not need.  When components depend on things they don’t need or use, we are adding risk for no value….this hurts us.  Systems that do this repeatedly suffer from what is called “leaky abstractions”.  Contracts which are a form of abstraction are bloated and have been leaked all over and no one knows who depends on what anymore because massive blobs with everything are always flying around.  So, if all I need is customer name, my contract should only contain customer name.  This isolates me from the dependencies associated with customer address and all that entails.  Let’s flip the example on it’s head a little, say we have component A that wants to store the customer name and component B satisfies that need.  Component C comes along and says, ”hey, I want to include address as well”.  What if we try to satisfy this need through updating component B to accept address.  What if we forget to deploy component B and component C is deployed.  Most services today simply discard extra data and so the service returns a success (i.e. 200 response code) but only the customers name was saved.  Are we beginning to see the ways we are hurting ourselves?  Let me re-introduce a long held principle of mechanical engineering….don’t fix what isn’t broke.  If component A and component B are working just fine together with an established contract, don’t change it.  Contracts should be seen as immutable.  If component A and component B get together and say that the previous contract needs to be changed, so be it.  Create a new contract (version or different name entirely) and tear up the old (deprecate / delete it).  Doing this correctly allows for easy rollback, rock solid deployments with 0 downtime and extremely simple troubleshooting (i.e. 404…service not found) and avoids all potential issues listed above.

Where loose coupling with the “how” is achieved by supporting as broad an audience as possible generally through http endpoints, loose coupling with the “what” of contract design is by defining tight contracts that meet the business need and only that need, no extras, no frills.  
Let me show this all with some simple illustrations

Now, likely rolling through your mind are likely the host of problems this causes.  How can we manage all these different versions, permutations of services contracts, complexities that this introduces in it’s own right.  Those, my friends, are the right questions.  I could devote several blog posts to each of them but let me begin by just shedding some light on these subjects and providing some hope.  

First, because we have separate “contracts” does not mean that we have completely separate implementations for those contracts.  In fact, some situations may require us to share some core components between implementations.  Perfect example of this may be a relational database.  We may have a single customer table that multiple components use, one component may just fetch the customer name while another may fetch the customer name and address.  These shared components though will require more scrutiny as they are where our system is coupled and thus the highest risk.  

Second, in some cases where we can not presume to understand what our customer needs, we may give them a series of services to allow them to innovate on their own without negotiating with us new contracts.  Examples of this may be a set of customer search services that return customer id’s and then a series of customer detail services that return various details about a given customer or customers.  This happens in some scenarios but also be warned, this is also a form of leaky abstractions and has many of the risk mentioned above.  Furthermore, don’t let this be a crutch to excuse not understanding your customer or business.  If you don’t understand your customer, stop, spend time understanding your customer’s needs, then write code.  Having awesome developers that don’t understand the business is like having a sports car without a steering wheel.  So, in summary on this point, this is not an ideal state but in some situations a necessary compromise.  

Thirdly, time, often I hear complaints about this taking more time to follow.  When thinking this always remember to factor in the extra time that “should” be spent testing and all the risk the tight coupling following the previous approaches entail.  With risk comes the late night phone calls or extra time spent debugging systems.  Also, examine the architecture and designs.  There are ways to make creating new services and versions super simple.  Sometimes a few base classes / abstractions, a little powershell magic, and you have a very robust framework for creating service endpoints.  A little effort making this a simple task will also have the benefit of improving your velocity when no matter your philosophy on contract design, you would need to create a new service.

Lastly, REST, this doesn’t sound like REST or at least it may be difficult to follow with REST.  Let me be the first to say that I think REST has been way oversold.  REST can be good in some situations as it has some nice self-discovery kinds of features with hypermedia links but extending it beyond a basic CRUD model organized around nouns gets to be challenging to say the least.  Again, maybe a topic for another blog post but modeling a business in my opinion is best done by looking at the actions or behaviors as opposed to the things of the system.  Some situations may fit very nicely with REST but plenty do not.

The views of REST tend to ignore the issues with leaky abstractions and the other issues mentioned above in favor of some utopian services.  The problem is the business world is best understood in terms of actions.  The users of a system will say, “when I click this button I want this value to display here and for it to be updated on the previous screen as well.”  I’m not saying REST is bad or that it isn’t a good way to define services.  Rest works extremely well with noun based organization of systems and defining very basic CRUD type operations against them.  It tends to fall apart when you try to model a business who’s behaviors blur the lines.  Consider business actions that change the state of multiple nouns or queries for that matter.  If we try to hold onto REST we end up needing to build an orchestration layer over the top of our CRUD based REST calls.  What is that orchestration layer?  Well, that is our business services?  Are they REST?  Can we preserve transactions when crossing multiple REST calls?  REST tends to fall apart when attempting to align it to a business.  If you want to expose an API for customers to consume and build custom solutions…maybe.  The problems with REST don’t go away, they are still there just you don’t need to deal with them, your customers do.

I liken it to the 3rd normal form, relational databases of the early 90’s.  During that time every system that was “modern” or “new” was adopting a relational database and the quality of your storage layer was based on how well you followed 3rd normal form (or 4th or 5th if you were the best).  What quickly resulted was an industry full of SQL queries that spanned pages with specialized database engineers that knew how to extract performance from such hideous monstrosities.  Oh and forget testing, that is basically trial and error.  Actually, this issue is still widespread today but over the last few years NoSQL type stores have come into the fold and are now being used more and more.  The reality is, we have always had NoSql type stores.  That is what we had back before relational databases.  Document stores, hash maps, all kinds of unique ways to store data which matched the use case.

* It decreases our velocity as thorough testing would now required us to retest the work we did with component A and B.

* We hide behind REST saying well we know we need a customer so here are the 4 crud operations to support customer yet we haven’t really establish what problem is the business wants solved.  Enter agile philosophies into the mix.

Postel's law was first mentioned as it relates to the TCP standard but later became recognized as matching many other concerns.  This is generally the first time we start thinking of contracts.  But before we talk about the “what” lets cover the easier topic of “how”.  When we look at communicating cross process and almost always cross server we tend to gravitate to http / https over TCP.  True, there are other protocols and approaches that are lighter weight but generally we favor http.  Why though?  The simple answer is that it is so universal.  Every language worth anything can communicate with a service hosting an http service.  Raw TCP or UDP while in some edge cases may be warranted just take more time to put together.  Contracts wise it is an obvious place to start as it is the most common scenario where developers start to talk about contract
