# Top 10 things every developer should know about time

Recently I had the privilege of fixing a software bug related to incorrect handling of time.  Over the course of my career I have fixed many different types of time issues, many of my own making.  I have learned some valuable lessons from these experiences.  Here are my top 10 things I think every developer should know.  For brevity, when I mention time I in this post I am always referring to date and time together.

1. It can be hard or impossible to convert local time to UTC.  To understand why think of daylight savings time.  If it is 1:30 AM on Sunday, November 4th 2018 what time is it UTC?  Well, that time occurs twice that day so the correct UTC conversion is unknowable without additional information.
2. Operating systems have good support for converting from UTC to local time for the currently configured locality.  They are poor at converting from UTC to other time zones.  The required locality may not be installed, updated to current rules, etc.  In some cases the API’s are really lacking for these sorts of needs.
3. Time zones are ridiculously complicated and attempting to manually convert between them should not be undertaken without significant analysis.  Just google some of the rules around local time, DST, changes to laws for time zones over the last century, etc. if you want to get a little frustrated with the governments of the world.  In some cases the laws were so ambiguous or completely ignored by the population that people can’t even agree what the rules actually were at the given time.
4. File times in windows operating system are “deterministic” which means they are UTC + a fixed offset for all file time values.  This has the interesting side effect of causing all local times of files to change after DST.  That is why many api’s expose “FileTime” as a separate conversion option between UTC and local.  I found this one after a system I wrote crashed after DST.  It was comparing local file times to recorded values in a database.  The fix for my system was to simply use UTC instead of local time.  That resolved my issue.
5. JsonConvert in .Net will serialize a DateTime.Now or any DateTime with a with a DateTimeKind of local with a UTC offset (e.x. “2018-06-10T11:45:09.0704134-5:00”).  If you send this over the wire to a server with a different locality / UTC offset and deserialize the value you will get a different time in the DateTime instance.  (e.x. would convert to 2018-06-10 9:45:09.0704134 if the server UTC offset was 7).  Add distributed computing cross regional data centers, cloud hosting, local development testing, etc. and this can be a nasty little bug to find and solve.  In short, be aware of this and in most cases do not send DateTime’s created from DateTime.Now or local kind across the wire.  If you really need or want to do this, work on adjusting the default serialization / deserializations for JsonConvert to handle this the way you need it to work.  Yeah, lost a good half day sorting this bug out.
6. The client can not be trusted with determining the current time for critical tasks.  If knowing the correct time is important, do this server side and if needed send that value to the client.  It is very easy for someone to change their local computer time or for the local computer time to be wildly inaccurate.
7. Current times across servers will be different.  Hopefully only by a few hundred milliseconds but in some more extreme cases I’ve seen things off by more than 2 minutes.  It will be difficult to perfectly synchronize times across servers so relying on server time for things like understanding ordering of events can be finicky.
8. Understand when components need to be “timeless”.  For instance, a component that is consuming messages from a queue or message bus may get behind, go down for a period of time, etc.  Using current time may in some situations result in bugs being reported in software (i.e. “I submitted a request but it shows it was submitted 10 minutes after I submitted it”).
9. There is not always 24 hours in a day.  Sometimes there is 23 other times there are 25.  I’m sure if you do a few google searches there are a few governments who did far worse than ours and created a few other variations.
10. How old are you?  Well this is way harder than one might think.  Systems only record the date someone was born.  Then, displaying their age for users in different regions of the world can get a little tricky.  What if those users are communicating over the phone viewing that information simultaneously (e.g.  “I see John is 37 on my screen, you say he is 38?”).  Just think about this issue in the context of a 24 / 7 user base.  What about individuals born on Feb 29th during a leap year.  Yeah, understanding the business use cases and making some strategic compromises will be important.

I hope you found this helpful and maybe learned a few things.  If you have any of your own horror stories around time feel free to share.  I’d love to hear them.  There are plenty of posts out there if you look.  These are just some of the things I keep in mind as I’m considering using time values within a system.